# Custom Templates Tutorial

This tutorial will guide you through creating custom code generation templates for JAFF.

## Overview

JAFF uses Jinja2 templates to generate code from chemical reaction networks. Custom templates allow you to:

- Generate code in any programming language
- Customize output format and structure
- Add project-specific features
- Integrate with existing codebases

## Prerequisites

Before starting this tutorial, you should:

- Have JAFF installed
- Understand basic Jinja2 syntax
- Be familiar with the target programming language
- Know the structure of your reaction network

## Template Basics

### Template Location

Templates can be stored anywhere and referenced via command line:

```bash
jaff generate network.json --template my_template.jinja2
```

Or use the default template directory:

```bash
~/.jaff/templates/
```

### Basic Template Structure

A minimal template:

```jinja2
{# my_template.jinja2 #}
// Generated code for {{ network.name }}
// {{ network.num_species }} species, {{ network.num_reactions }} reactions

{% for species in network.species %}
// Species: {{ species.name }}
{% endfor %}

{% for reaction in network.reactions %}
// Reaction: {{ reaction.name }}
{% endfor %}
```

## Example 1: Python Function Generator

Let's create a template that generates Python functions for each reaction.

### Template File: `python_functions.jinja2`

```jinja2
"""
{{ network.name }}
Generated by JAFF
"""

import numpy as np

# Species indices
{% for species in network.species %}
{{ species.name.upper() }}_IDX = {{ loop.index0 }}
{% endfor %}

# Number of species
NUM_SPECIES = {{ network.num_species }}

{% for reaction in network.reactions %}
def {{ reaction.safe_name }}_rate(concentrations, parameters):
    """
    {{ reaction.equation }}
    Rate: {{ reaction.rate_expression }}
    """
    {% for reactant in reaction.reactants %}
    {{ reactant.name }} = concentrations[{{ reactant.name.upper() }}_IDX]
    {% endfor %}
    
    {% if reaction.parameters %}
    # Parameters
    {% for param in reaction.parameters %}
    {{ param }} = parameters['{{ param }}']
    {% endfor %}
    {% endif %}
    
    # Rate calculation
    rate = {{ reaction.rate_expression | to_python }}
    
    return rate

{% endfor %}

def reaction_rates(concentrations, parameters):
    """Calculate all reaction rates"""
    rates = np.zeros({{ network.num_reactions }})
    
    {% for reaction in network.reactions %}
    rates[{{ loop.index0 }}] = {{ reaction.safe_name }}_rate(concentrations, parameters)
    {% endfor %}
    
    return rates

def derivatives(t, concentrations, parameters):
    """Calculate time derivatives for ODE solver"""
    dc_dt = np.zeros(NUM_SPECIES)
    rates = reaction_rates(concentrations, parameters)
    
    {% for reaction in network.reactions %}
    # {{ reaction.equation }}
    {% for reactant in reaction.reactants %}
    dc_dt[{{ reactant.name.upper() }}_IDX] -= {{ reactant.stoichiometry }} * rates[{{ loop.parent.index0 }}]
    {% endfor %}
    {% for product in reaction.products %}
    dc_dt[{{ product.name.upper() }}_IDX] += {{ product.stoichiometry }} * rates[{{ loop.parent.index0 }}]
    {% endfor %}
    {% endfor %}
    
    return dc_dt
```

### Usage

```bash
jaff generate network.json --template python_functions.jinja2 -o model.py
```

## Example 2: C++ Class Generator

Create a template for a C++ simulation class.

### Template File: `cpp_class.jinja2`

```jinja2
#ifndef {{ network.name.upper() }}_H
#define {{ network.name.upper() }}_H

#include <vector>
#include <string>
#include <map>

class {{ network.name | title }}Model {
public:
    // Species indices
    {% for species in network.species %}
    static const int {{ species.name.upper() }} = {{ loop.index0 }};
    {% endfor %}
    
    static const int NUM_SPECIES = {{ network.num_species }};
    static const int NUM_REACTIONS = {{ network.num_reactions }};
    
    // Constructor
    {{ network.name | title }}Model();
    
    // Calculate reaction rates
    std::vector<double> reactionRates(
        const std::vector<double>& concentrations,
        const std::map<std::string, double>& parameters
    ) const;
    
    // Calculate derivatives
    std::vector<double> derivatives(
        double t,
        const std::vector<double>& concentrations,
        const std::map<std::string, double>& parameters
    ) const;
    
    // Get species names
    static std::vector<std::string> getSpeciesNames();
    
private:
    {% for reaction in network.reactions %}
    double {{ reaction.safe_name }}_rate(
        const std::vector<double>& c,
        const std::map<std::string, double>& p
    ) const;
    {% endfor %}
};

#endif // {{ network.name.upper() }}_H
```

### Implementation Template: `cpp_class_impl.jinja2`

```jinja2
#include "{{ network.name }}.h"
#include <cmath>

{{ network.name | title }}Model::{{ network.name | title }}Model() {}

std::vector<std::string> {{ network.name | title }}Model::getSpeciesNames() {
    return {
        {% for species in network.species %}
        "{{ species.name }}"{{ "," if not loop.last else "" }}
        {% endfor %}
    };
}

{% for reaction in network.reactions %}
double {{ network.name | title }}Model::{{ reaction.safe_name }}_rate(
    const std::vector<double>& c,
    const std::map<std::string, double>& p
) const {
    // {{ reaction.equation }}
    {% for reactant in reaction.reactants %}
    double {{ reactant.name }} = c[{{ reactant.name.upper() }}];
    {% endfor %}
    
    return {{ reaction.rate_expression | to_cpp }};
}

{% endfor %}

std::vector<double> {{ network.name | title }}Model::reactionRates(
    const std::vector<double>& concentrations,
    const std::map<std::string, double>& parameters
) const {
    std::vector<double> rates(NUM_REACTIONS);
    
    {% for reaction in network.reactions %}
    rates[{{ loop.index0 }}] = {{ reaction.safe_name }}_rate(concentrations, parameters);
    {% endfor %}
    
    return rates;
}

std::vector<double> {{ network.name | title }}Model::derivatives(
    double t,
    const std::vector<double>& concentrations,
    const std::map<std::string, double>& parameters
) const {
    std::vector<double> dc_dt(NUM_SPECIES, 0.0);
    std::vector<double> rates = reactionRates(concentrations, parameters);
    
    {% for reaction in network.reactions %}
    // {{ reaction.equation }}
    {% for reactant in reaction.reactants %}
    dc_dt[{{ reactant.name.upper() }}] -= {{ reactant.stoichiometry }} * rates[{{ loop.parent.index0 }}];
    {% endfor %}
    {% for product in reaction.products %}
    dc_dt[{{ product.name.upper() }}] += {{ product.stoichiometry }} * rates[{{ loop.parent.index0 }}];
    {% endfor %}
    {% endfor %}
    
    return dc_dt;
}
```

## Example 3: Julia Module Generator

### Template File: `julia_module.jinja2`

```jinja2
module {{ network.name | title }}

export reaction_rates, derivatives!, get_species_names

# Species indices
{% for species in network.species %}
const {{ species.name.upper() }}_IDX = {{ loop.index }}
{% endfor %}

const NUM_SPECIES = {{ network.num_species }}
const NUM_REACTIONS = {{ network.num_reactions }}

"""
Get species names
"""
function get_species_names()
    return [
        {% for species in network.species %}
        "{{ species.name }}"{{ "," if not loop.last else "" }}
        {% endfor %}
    ]
end

{% for reaction in network.reactions %}
"""
{{ reaction.equation }}
Rate: {{ reaction.rate_expression }}
"""
function {{ reaction.safe_name }}_rate(c, p)
    {% for reactant in reaction.reactants %}
    {{ reactant.name }} = c[{{ reactant.name.upper() }}_IDX]
    {% endfor %}
    
    return {{ reaction.rate_expression | to_julia }}
end

{% endfor %}

"""
Calculate all reaction rates
"""
function reaction_rates(concentrations, parameters)
    rates = zeros(NUM_REACTIONS)
    
    {% for reaction in network.reactions %}
    rates[{{ loop.index }}] = {{ reaction.safe_name }}_rate(concentrations, parameters)
    {% endfor %}
    
    return rates
end

"""
Calculate derivatives for ODE solver (in-place)
"""
function derivatives!(dc_dt, c, p, t)
    fill!(dc_dt, 0.0)
    rates = reaction_rates(c, p)
    
    {% for reaction in network.reactions %}
    # {{ reaction.equation }}
    {% for reactant in reaction.reactants %}
    dc_dt[{{ reactant.name.upper() }}_IDX] -= {{ reactant.stoichiometry }} * rates[{{ loop.parent.index }}]
    {% endfor %}
    {% for product in reaction.products %}
    dc_dt[{{ product.name.upper() }}_IDX] += {{ product.stoichiometry }} * rates[{{ loop.parent.index }}]
    {% endfor %}
    {% endfor %}
    
    return nothing
end

end # module
```

## Advanced Template Features

### Custom Filters

Define custom Jinja2 filters to transform expressions:

```python
# In your Python code
from jinja2 import Environment, FileSystemLoader

def to_matlab(expression):
    """Convert expression to MATLAB syntax"""
    return expression.replace('**', '.^').replace('*', '.*')

env = Environment(loader=FileSystemLoader('templates'))
env.filters['to_matlab'] = to_matlab
```

### Conditional Code Generation

```jinja2
{% if network.has_reversible_reactions %}
// Handle reversible reactions
{% for reaction in network.reversible_reactions %}
double {{ reaction.safe_name }}_forward = ...;
double {{ reaction.safe_name }}_reverse = ...;
{% endfor %}
{% endif %}
```

### Macros for Reusable Code

```jinja2
{% macro generate_rate_function(reaction) %}
double {{ reaction.safe_name }}_rate(const double* c, const double* p) {
    return {{ reaction.rate_expression }};
}
{% endmacro %}

{% for reaction in network.reactions %}
{{ generate_rate_function(reaction) }}
{% endfor %}
```

### Include Other Templates

```jinja2
{# header.jinja2 #}
{% include 'copyright.jinja2' %}
{% include 'imports.jinja2' %}

// Main code follows...
```

## Template Variables Reference

### Network Object

- `network.name` - Network name
- `network.num_species` - Number of species
- `network.num_reactions` - Number of reactions
- `network.species` - List of species objects
- `network.reactions` - List of reaction objects

### Species Object

- `species.name` - Species name
- `species.index` - Species index
- `species.initial_concentration` - Initial value (if available)

### Reaction Object

- `reaction.name` - Reaction name
- `reaction.safe_name` - Valid identifier name
- `reaction.equation` - Human-readable equation
- `reaction.rate_expression` - Rate law expression
- `reaction.reactants` - List of reactant objects
- `reaction.products` - List of product objects
- `reaction.parameters` - List of parameter names

## Testing Your Template

### Create a Test Network

```json
{
  "name": "test_network",
  "species": [
    {"name": "A"},
    {"name": "B"},
    {"name": "C"}
  ],
  "reactions": [
    {
      "name": "r1",
      "reactants": [{"species": "A", "stoichiometry": 1}],
      "products": [{"species": "B", "stoichiometry": 1}],
      "rate": "k1 * A"
    }
  ]
}
```

### Generate and Verify

```bash
# Generate code
jaff generate test_network.json --template my_template.jinja2 -o output.txt

# Check output
cat output.txt

# Test compilation (for compiled languages)
gcc output.c -o test
./test
```

## Best Practices

### 1. Template Organization

```
templates/
├── python/
│   ├── base.jinja2
│   ├── ode.jinja2
│   └── stochastic.jinja2
├── cpp/
│   ├── header.jinja2
│   └── implementation.jinja2
└── common/
    ├── copyright.jinja2
    └── documentation.jinja2
```

### 2. Documentation in Templates

```jinja2
{# 
Template: Python ODE Model Generator
Author: Your Name
Date: 2024
Description: Generates Python code for ODE simulation
#}
```

### 3. Error Handling

```jinja2
{% if not network.species %}
# ERROR: No species defined in network
{% else %}
// Normal code generation
{% endif %}
```

### 4. Code Formatting

Use Jinja2's whitespace control:

```jinja2
{% for item in items -%}
    {{ item }}
{%- endfor %}
```

### 5. Validation

Add validation checks:

```jinja2
{% if network.num_species > 1000 %}
#warning "Large network: {{ network.num_species }} species"
{% endif %}
```

## Troubleshooting

### Template Not Found

```bash
# Check template path
jaff generate network.json --template /full/path/to/template.jinja2
```

### Syntax Errors

```bash
# Validate Jinja2 syntax
python -c "from jinja2 import Template; Template(open('template.jinja2').read())"
```

### Missing Variables

Add defaults:

```jinja2
{{ reaction.description | default("No description") }}
```

## Next Steps

- Explore the [Template Syntax](../user-guide/template-syntax.md) guide
- Review [Template Variables Reference](../reference/template-variables.md)
- Check [Code Generation Guide](../user-guide/code-generation.md)
- See [Network Analysis Tutorial](network-analysis.md) for data extraction

## Additional Resources

- [Jinja2 Documentation](https://jinja.palletsprojects.com/)
- [Template Examples Repository](https://github.com/your-org/jaff-templates)
- [Community Templates](https://github.com/your-org/jaff-community-templates)
