import os

def main(network, path_template, path_build=None):
    from jaff.preprocessor import Preprocessor

    p = Preprocessor()

    ## Generate C++ code using header-only integrators (VODE)

    # Get species indices and counts with C++ formatting
    scommons = network.get_commons(idx_offset=0, idx_prefix="", definition_prefix="static constexpr int ")

    # Add semicolons for C++ syntax
    scommons = '\n'.join([line + ';' if line.strip() and not line.strip().endswith(';') else line for line in scommons.split('\n')])
    
    # Add common chemistry variables that are used in rate expressions
    # These are typically parameters that should be passed in or computed
    chemistry_vars = """// Common chemistry variables used in rate expressions
// These should typically be passed as parameters or computed from the state
static constexpr double DEFAULT_TEMPERATURE = 300.0;  // Default gas temperature in K
static constexpr double DEFAULT_AV = 1.0;             // Default visual extinction
static constexpr double DEFAULT_CRATE = 1.3e-17;      // Default cosmic ray ionization rate
static constexpr double K_BOLTZ = 1.380649e-16;       // Boltzmann constant [erg/K]
static constexpr double M_H = 1.6735575e-24;          // Hydrogen mass [g]
"""
    
    # Combine species indices with chemistry variables, but avoid redefining nspecs here
    scommons_lines = scommons.split("\n")
    scommons_lines = [ln for ln in scommons_lines if not ln.strip().startswith("static constexpr int nspecs ")]
    scommons = "\n".join(scommons_lines)
    scommons = scommons + "\n" + chemistry_vars
    
    # Get reaction rates with C++ syntax and CSE optimization
    rates = network.get_rates(idx_offset=0, rate_variable="k", language="c++", use_cse=True)
    # Ensure we use standard <cmath> namespace, not Kokkos math wrappers
    rates = rates.replace("Kokkos::", "std::")
    
    # Generate symbolic ODE and analytical Jacobian
    sode, jacobian = network.get_symbolic_ode_and_jacobian(idx_offset=0, use_cse=True, language="c++")
    # Convert Jacobian indexing from J(i, j) (Kokkos view style) to J[i][j] (std::array style)
    # This keeps the network generator stable while adapting to header-only integrators API
    import re
    jacobian = re.sub(r"J\((\d+)\s*,\s*(\d+)\)", r"J[\1][\2]", jacobian)
    
    # Generate temperature variable definitions for C++ from internal energy
    temp_vars = """// Temperature and environment variables used in chemical reactions
// Compute gas temperature from internal energy and composition
const double tgas = compute_temperature(y[static_cast<size_t>(idx_eint)], y);
const double tdust = tgas; // simple assumption; adjust as needed
const double av = DEFAULT_AV;  // Visual extinction
const double crate = DEFAULT_CRATE;  // Cosmic ray ionization rate
"""

    # Generate gamma and temperature helpers
    temperature_func = """// Mixture gamma and temperature helpers generated by JAFF
// compute_gamma: estimate mixture adiabatic index from composition
// Assumptions (rigid-rotor, no vibrational excitation):
//  - monoatomic species: cv/kB = 3/2, cp/kB = 5/2 -> gamma = 5/3
//  - diatomic species:  cv/kB = 5/2, cp/kB = 7/2 -> gamma = 7/5
//  - polyatomic (>=3 atoms): cv/kB = 3,   cp/kB = 4   -> gamma = 4/3
static inline double compute_gamma(const state_type& nden) {
    double ntot = 0.0;
    for (int i = 0; i < nspecs; ++i) ntot += nden[static_cast<size_t>(i)];
    if (ntot <= 0.0) return NAN; // undefined mixture
    double cp_over_k = 0.0;
    double cv_over_k = 0.0;
    for (int i = 0; i < nspecs; ++i) {
        const auto ni = nden[static_cast<size_t>(i)];
        const double xi = ni / ntot; // number fraction
        // Determine species class by atom count
        const int nat = species_natoms[static_cast<size_t>(i)];
        double cp_i = 0.0;
        double cv_i = 0.0;
        if (nat <= 1) {        // Monatomic
            cv_i = 1.5; cp_i = 2.5;
        } else if (nat == 2) { // Diatomic (no vibrational modes active)
            cv_i = 2.5; cp_i = 3.5;
        } else {               // Polyatomic (>=3 atoms)
            cv_i = 3.0; cp_i = 4.0;
        }
        cv_over_k += xi * cv_i;
        cp_over_k += xi * cp_i;
    }
    if (cv_over_k <= 0.0) return NAN; // undefined mixture
    return cp_over_k / cv_over_k;
}

// Compute gas temperature from internal energy density and species number densities.
// eint: internal energy density [erg cm^-3]; nden: species number densities [cm^-3]
// Mean molecular weight is computed from composition: mu = rho / (n_tot * M_H)
static inline double compute_temperature(double eint, const state_type& nden) {
    double ntot = 0.0;
    double rho = 0.0; // mass density [g cm^-3]
    for (int i = 0; i < nspecs; ++i) {
        const auto ni = nden[static_cast<size_t>(i)];
        ntot += ni;
        rho  += ni * species_mass[static_cast<size_t>(i)];
    }
    if (ntot <= 0.0 || rho <= 0.0) {
        return NAN;
    }
    const double mu = rho / (ntot * M_H);
    const double gamma = compute_gamma(nden);
    return (gamma - 1.0) * eint * mu * M_H / (rho * K_BOLTZ);
}

// Compute internal energy density [erg cm^-3] from number densities and temperature.
// Returns NAN if inputs are not physically meaningful.
static inline double compute_internal_energy(const state_type& nden, double T) {
    double ntot = 0.0;
    for (int i = 0; i < nspecs; ++i) {
        ntot += nden[static_cast<size_t>(i)];
    }
    if (ntot <= 0.0) return NAN;
    if (T <= 0.0) return NAN;
    const double gamma = compute_gamma(nden);
    if (!(gamma > 1.0)) return NAN;
    return ntot * K_BOLTZ * T / (gamma - 1.0);
}
"""

    # Process template files
    num_species = str(network.get_number_of_species())
    num_reactions = str(len(network.reactions))
    
    # Generate proper C++ array declarations
    # When using CSE, we don't need the flux array
    num_reactions_decl = f"double k[{num_reactions}];"
    
    # Build conservation metadata for C++ template injection
    # Elements present across species (exclude non-atomic tokens and electrons)
    import re
    element_keys = []
    for sp in network.species:
        # sp.exploded contains atomic symbols and possible tokens; filter later
        for atom in sp.exploded:
            if re.match(r"^[A-Z][a-z]?$", atom):
                if atom not in element_keys:
                    element_keys.append(atom)
    # Deterministic order
    element_keys.sort()

    # Species charges
    charges = [str(int(sp.charge)) for sp in network.species]

    # Element-species count matrix
    elem_rows = []
    for elem in element_keys:
        counts = []
        for sp in network.species:
            counts.append(str(sp.exploded.count(elem)))
        elem_rows.append("{" + ", ".join(counts) + "}")

    # C++ metadata block
    if element_keys:
        element_names_cpp = ", ".join([f'"{e}"' for e in element_keys])
        conservation_metadata = []
        conservation_metadata.append("#define JAFF_HAS_CONSERVATION_METADATA 1")
        conservation_metadata.append(f"constexpr int n_elements = {len(element_keys)};")
        conservation_metadata.append(f"constexpr const char* element_names[n_elements] = {{{element_names_cpp}}};")
        conservation_metadata.append(f"constexpr int species_charge[ChemistryODE::nspecs] = {{{', '.join(charges)}}};")
        conservation_metadata.append(
            f"constexpr int elem_matrix[n_elements][ChemistryODE::nspecs] = {{{', '.join(elem_rows)}}};"
        )
        conservation_metadata_cpp = "\n".join(conservation_metadata)
    else:
        conservation_metadata_cpp = ""  # no elements â€“ skip injection

    # Species mass array (g per particle) for mean molecular weight computation
    masses = [f"{sp.mass:.10e}" for sp in network.species]
    species_mass_cpp = f"static constexpr double species_mass[ChemistryODE::nspecs] = {{{', '.join(masses)}}};"
    # Species atom counts (used to infer per-species heat capacities and gamma)
    natoms_list = []
    for sp in network.species:
        count = 0
        for atom in sp.exploded:
            if re.match(r"^[A-Z][a-z]?$", atom) or atom == 'e-':
                count += 1
        if count <= 0:
            count = 1
        natoms_list.append(str(count))
    species_natoms_cpp = f"static constexpr int species_natoms[ChemistryODE::nspecs] = {{{', '.join(natoms_list)}}};"

    # Process all files with auto-detected comment styles
    # Append an internal energy equation (placeholder: zero RHS) so energy is carried in state
    sode_with_eint = sode + "f[idx_eint] = 0.0;\n"

    p.preprocess(path_template,
                 ["chemistry_ode.hpp", "chemistry_ode.cpp", "CMakeLists.txt"],
                 [{"COMMONS": scommons + "\n" + species_mass_cpp + "\n" + species_natoms_cpp, "RATES": rates, "ODE": sode_with_eint, "JACOBIAN": jacobian,
                   "NUM_SPECIES": f"static constexpr int nspecs = {num_species};\nstatic constexpr int nvars = nspecs + 1;\nstatic constexpr int idx_eint = nspecs;",
                   "NUM_REACTIONS": num_reactions_decl, "TEMP_VARS": temp_vars,
                   "TEMPERATURE_FUNC": temperature_func},
                  {"COMMONS": scommons + "\n" + species_mass_cpp + "\n" + species_natoms_cpp, "RATES": rates, "ODE": sode_with_eint, "JACOBIAN": jacobian,
                   "NUM_SPECIES": f"static constexpr int nspecs = {num_species};\nstatic constexpr int nvars = nspecs + 1;\nstatic constexpr int idx_eint = nspecs;",
                   "NUM_REACTIONS": num_reactions, "TEMP_VARS": temp_vars,
                   "CONSERVATION_METADATA": conservation_metadata_cpp,
                   "TEMPERATURE_FUNC": temperature_func},
                  {"NUM_SPECIES": num_species}],
                 comment="auto",
                 path_build=path_build)
