// ABOUTME: Main executable for solving chemistry ODE using Kokkos-kernels BDF solver
// ABOUTME: Auto-generated by JAFF for chemical reaction network integration

#include "chemistry_ode.hpp"
#include <Kokkos_Core.hpp>
#include <KokkosODE_BDF.hpp>
#include <iostream>
#include <fstream>
#include <vector>
#include <string>

// Wrapper for BDF solver with adaptive time stepping
template <class ode_type, class vec_type, class mat_type, class scalar_type>
struct BDF_Solve_wrapper {
    ode_type my_ode;
    scalar_type t_start, t_end, dt, max_step;
    vec_type y0, y_new;
    mat_type temp, temp2;

    BDF_Solve_wrapper(const ode_type& my_ode_, const scalar_type& t_start_, const scalar_type& t_end_,
                     const scalar_type& dt_, const scalar_type& max_step_, const vec_type& y0_, 
                     const vec_type& y_new_, const mat_type& temp_, const mat_type& temp2_)
        : my_ode(my_ode_),
          t_start(t_start_),
          t_end(t_end_),
          dt(dt_),
          max_step(max_step_),
          y0(y0_),
          y_new(y_new_),
          temp(temp_),
          temp2(temp2_) {}

    KOKKOS_FUNCTION void operator()(const int) const {
        KokkosODE::Experimental::BDFSolve(my_ode, t_start, t_end, dt, max_step, y0, y_new, temp, temp2);
    }
};

int main(int argc, char* argv[]) {
    Kokkos::initialize(argc, argv);
    
    {
        using execution_space = Kokkos::DefaultExecutionSpace;
        using scalar_type = double;
        using vec_type = Kokkos::View<scalar_type*, execution_space>;
        using mat_type = Kokkos::View<scalar_type**, execution_space>;
        
        ChemistryODE mySys{};
        
        // Time integration parameters
        const scalar_type t_start = 0.0;
        scalar_type t_end = 3.15576e9; // 100 years in seconds default
        
        // Parse command line arguments
        if (argc > 1) {
            t_end = std::stod(argv[1]);
        }
        
        std::cout << "Solving Chemistry ODE System\n";
        std::cout << "Number of species: " << mySys.neqs << "\n";
        std::cout << "Number of reactions: " << 
// PREPROCESS_NUM_REACTIONS
0
// PREPROCESS_END
         << "\n";
        std::cout << "Time interval: [" << t_start << ", " << t_end << "] seconds\n";
        
        // Allocate arrays
        vec_type y0("initial conditions", mySys.neqs);
        vec_type y_new("solution", mySys.neqs);
        
        // Set initial conditions (can be customized)
        auto y0_h = Kokkos::create_mirror_view(y0);
        
        // Default: all species start at 1e-10 except first species
        for (int i = 0; i < mySys.neqs; ++i) {
            y0_h(i) = 1.0e-10;
        }
        // Set first species to higher concentration
        if (mySys.neqs > 0) {
            y0_h(0) = 1.0e-6;
        }
        
        // Read initial conditions from file if provided
        if (argc > 2) {
            std::ifstream ic_file(argv[2]);
            if (ic_file.is_open()) {
                for (int i = 0; i < mySys.neqs && ic_file >> y0_h(i); ++i) {}
                ic_file.close();
                std::cout << "Initial conditions loaded from " << argv[2] << "\n";
            }
        }
        
        Kokkos::deep_copy(y0, y0_h);
        
        // Print initial conditions
        std::cout << "Initial conditions:\n";
        for (int i = 0; i < mySys.neqs && i < 10; ++i) {
            std::cout << "  y[" << i << "] = " << y0_h(i) << "\n";
        }
        if (mySys.neqs > 10) {
            std::cout << "  ... (showing first 10 species)\n";
        }
        
        // Allocate temporary storage for BDF solver
        mat_type temp("buffer1", mySys.neqs, 23 + 2 * mySys.neqs + 4);
        mat_type temp2("buffer2", 6, 7);
        
        // Initial time step (will be adapted by solver)
        scalar_type dt = 1.0e-10;
        scalar_type max_step = (t_end - t_start) / 100.0;
        
        // Create solver wrapper
        BDF_Solve_wrapper<ChemistryODE, vec_type, mat_type, scalar_type> bdf_wrapper(
            mySys, t_start, t_end, dt, max_step, y0, y_new, temp, temp2);
        
        // Run solver
        Kokkos::RangePolicy<execution_space> policy(0, 1);
        Kokkos::parallel_for(policy, bdf_wrapper);
        Kokkos::fence();
        
        // Copy solution back to host
        auto y_new_h = Kokkos::create_mirror_view(y_new);
        Kokkos::deep_copy(y_new_h, y_new);
        
        // Print final solution
        std::cout << "\nFinal solution at t = " << t_end << " seconds:\n";
        for (int i = 0; i < mySys.neqs && i < 10; ++i) {
            std::cout << "  y[" << i << "] = " << y_new_h(i) << "\n";
        }
        if (mySys.neqs > 10) {
            std::cout << "  ... (showing first 10 species)\n";
        }
        
        // Write solution to file if output path provided
        if (argc > 3) {
            std::ofstream out_file(argv[3]);
            if (out_file.is_open()) {
                for (int i = 0; i < mySys.neqs; ++i) {
                    out_file << y_new_h(i) << "\n";
                }
                out_file.close();
                std::cout << "\nSolution written to " << argv[3] << "\n";
            }
        }
        
        // Check conservation (sum of all species)
        double sum_initial = 0.0, sum_final = 0.0;
        for (int i = 0; i < mySys.neqs; ++i) {
            sum_initial += y0_h(i);
            sum_final += y_new_h(i);
        }
        std::cout << "\nConservation check:\n";
        std::cout << "  Initial sum: " << sum_initial << "\n";
        std::cout << "  Final sum:   " << sum_final << "\n";
        std::cout << "  Relative change: " << (sum_final - sum_initial) / sum_initial << "\n";
        
        std::cout << "\nKokkos execution space: " 
                  << typeid(Kokkos::DefaultExecutionSpace).name() << std::endl;
    }
    
    Kokkos::finalize();
    
    return 0;
}
