// ABOUTME: Main executable for solving chemistry ODE using header-only integrators (VODE)
// ABOUTME: Auto-generated by JAFF for chemical reaction network integration

#include "chemistry_ode.hpp"
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>

using namespace integrators;

int main(int argc, char* argv[]) {
    ChemistryODE mySys{};

    // Time integration parameters
    const Real t_start = 0.0;
    Real t_end = 3.15576e9; // 100 years in seconds default

    // Parse command line arguments
    // Positional args (in order): t_end [ic_file] [out_file]
    // Flags (any position): --analytic-jac | --numerical-jac | --help
    bool analytic_jac = false; // default to numerical Jacobian for robustness
    int positional = 0;
    std::string ic_path;
    std::string out_path;
    for (int i = 1; i < argc; ++i) {
        std::string arg(argv[i]);
        if (arg == "--help" || arg == "-h") {
            std::cout << "Usage: chemistry_ode [t_end] [ic_file] [out_file] [--analytic-jac|--numerical-jac]\n";
            return 0;
        } else if (arg == "--analytic-jac") {
            analytic_jac = true;
        } else if (arg == "--numerical-jac") {
            analytic_jac = false;
        } else if (!arg.empty() && arg[0] == '-') {
            std::cerr << "Unknown option: " << arg << "\n";
            return 1;
        } else {
            // positional
            if (positional == 0) {
                t_end = std::stod(arg);
            } else if (positional == 1) {
                ic_path = arg;
            } else if (positional == 2) {
                out_path = arg;
            }
            positional++;
        }
    }

    std::cout << "Solving Chemistry ODE System (header-only integrators)\n";
    std::cout << "Number of species: " << mySys.neqs << "\n";
    std::cout << "Number of reactions: " << 
// PREPROCESS_NUM_REACTIONS
0
// PREPROCESS_END
     << "\n";
    std::cout << "Time interval: [" << t_start << ", " << t_end << "] seconds\n";

    // Initial conditions
    ChemistryODE::state_type y0{};

    // Default: all species start at 1e-10 except first species
    for (int i = 0; i < mySys.neqs; ++i) {
        y0[static_cast<size_t>(i)] = 1.0e-10;
    }
    if (mySys.neqs > 0) {
        y0[0] = 1.0e-6;
    }

    // Read initial conditions from file if provided (2nd positional arg)
    if (!ic_path.empty()) {
        std::ifstream ic_file(ic_path);
        if (ic_file.is_open()) {
            for (int i = 0; i < mySys.neqs && (ic_file >> y0[static_cast<size_t>(i)]); ++i) {}
            ic_file.close();
            std::cout << "Initial conditions loaded from " << ic_path << "\n";
        }
    }

    // Print initial conditions
    std::cout << "Initial conditions:\n";
    for (int i = 0; i < mySys.neqs; ++i) {
        std::cout << "  nden[" << i << "] = " << std::setprecision(10) << y0[static_cast<size_t>(i)] << "\n";
    }

    // Set up integrator (VODE BDF)
    auto integrator = VODE<ChemistryODE>{};
    auto state = VODEState<static_cast<size_type>(ChemistryODE::neqs)>{};

    // Configure state
    state.t = t_start;
    state.tout = t_end;
    for (size_t i = 0; i < static_cast<size_t>(ChemistryODE::neqs); ++i) state.y[i] = y0[i];
    state.rtol = 1.e-5;
    state.atol = 1.e-20; // chemistry can have very small values
    state.max_steps = 200000;
    state.jacobian_analytic = analytic_jac;

    std::cout << "Jacobian: " << (state.jacobian_analytic ? "analytic" : "numerical") << "\n";

    // Problem state (reserved for problem parameters; unused here)
    ChemistryODE::state_type problem_state{};

    auto result = integrator.integrate(problem_state, state);

    // Print final solution
    std::cout << "\nFinal solution at t = " << t_end << " seconds:\n";
    for (int i = 0; i < mySys.neqs; ++i) {
        std::cout << "  nden[" << i << "] = " << std::setprecision(10) << state.y[static_cast<size_t>(i)] << "\n";
    }

    // Write solution to file if output path provided (3rd positional arg)
    if (!out_path.empty()) {
        std::ofstream out_file(out_path);
        if (out_file.is_open()) {
            for (int i = 0; i < mySys.neqs; ++i) {
                out_file << std::setprecision(17) << state.y[static_cast<size_t>(i)] << "\n";
            }
            out_file.close();
            std::cout << "\nSolution written to " << out_path << "\n";
        }
    }

    // Removed legacy raw-sum conservation check (not a true invariant)

    // Element and charge conservation report
    // The codegen may inject species-element stoichiometry and charges here.
    // Expected injected definitions (all constexpr/static):
    //   JAFF_HAS_CONSERVATION_METADATA = true
    //   n_elements (int), element_names[n_elements] (const char*),
    //   species_charge[ChemistryODE::neqs] (int),
    //   elem_matrix[n_elements][ChemistryODE::neqs] (int counts per species)
    // If not provided, we skip this report gracefully.
    // PREPROCESS_CONSERVATION_METADATA
    // PREPROCESS_END
    
    #ifndef JAFF_HAS_CONSERVATION_METADATA
    constexpr bool JAFF_HAS_CONSERVATION_METADATA = false;
    #endif
    if constexpr (JAFF_HAS_CONSERVATION_METADATA) {
        std::cout << "\nElement/charge conservation:\n";
        // Elements
        for (int e = 0; e < n_elements; ++e) {
            long double init = 0.0L, fin = 0.0L;
            for (int j = 0; j < ChemistryODE::neqs; ++j) {
                init += static_cast<long double>(elem_matrix[e][j]) * static_cast<long double>(y0[static_cast<size_t>(j)]);
                fin  += static_cast<long double>(elem_matrix[e][j]) * static_cast<long double>(state.y[static_cast<size_t>(j)]);
            }
            const long double rel = (init != 0.0L) ? (fin - init) / init : 0.0L;
            std::cout.setf(std::ios::scientific, std::ios::floatfield);
            std::cout.precision(10);
            std::cout << "  " << element_names[e]
                      << ": init=" << static_cast<double>(init)
                      << ", final=" << static_cast<double>(fin)
                      << ", rel_delta=" << static_cast<double>(rel) << "\n";
        }
        // Net charge
        long double q_init = 0.0L, q_fin = 0.0L;
        for (int j = 0; j < ChemistryODE::neqs; ++j) {
            q_init += static_cast<long double>(species_charge[j]) * static_cast<long double>(y0[static_cast<size_t>(j)]);
            q_fin  += static_cast<long double>(species_charge[j]) * static_cast<long double>(state.y[static_cast<size_t>(j)]);
        }
        const long double q_rel = (q_init != 0.0L) ? (q_fin - q_init) / q_init : 0.0L;
        std::cout << "  net_charge: init=" << static_cast<double>(q_init)
                  << ", final=" << static_cast<double>(q_fin)
                  << ", rel_delta=" << static_cast<double>(q_rel) << "\n";
    } else {
        std::cout << "\n(Element/charge conservation metadata not available in this build)\n";
    }

    if (result != IntegratorResult::SUCCESS) {
        std::cerr << "\nIntegration did not succeed. Error code = " << static_cast<int>(result) << "\n";
        // Diagnostics: print failed step index and key integrator state
        auto dump_state = [](const VODEState<static_cast<size_type>(ChemistryODE::neqs)>& s) {
            std::cerr.setf(std::ios::scientific, std::ios::floatfield);
            std::cerr.precision(17);
            std::cerr << "Failure diagnostics:" << '\n';
            std::cerr << "  failed_at_step = " << (s.n_step + 1) << " (completed=" << s.n_step << ")" << '\n';
            std::cerr << "  t = " << s.t << ", tn = " << s.tn << ", tout = " << s.tout << '\n';
            std::cerr << "  H = " << s.H << ", NQ = " << int(s.NQ) << ", L = " << int(s.L) << '\n';
            std::cerr << "  ETA = " << s.ETA << ", RC = " << s.RC << ", ETAMAX = " << s.ETAMAX << '\n';
            std::cerr << "  err_fails = " << s.err_fails << ", n_rhs = " << s.n_rhs << ", n_jac = " << s.n_jac << '\n';
            std::cerr << "  flags: ICF=" << int(s.ICF) << ", IPUP=" << int(s.IPUP) << ", JCUR=" << int(s.JCUR)
                      << ", NEWH=" << int(s.NEWH) << ", NEWQ=" << int(s.NEWQ) << ", NQWAIT=" << int(s.NQWAIT) << '\n';
            std::cerr << "  norms: acnrm_last = " << s.acnrm_last
                      << ", TQ2 = " << s.tq[1] << ", TQ3 = " << s.tq[2]
                      << ", TQ4 = " << s.tq[3] << ", TQ5 = " << s.tq[4] << '\n';
            std::cerr << "  y[0:5] = ";
            for (int i = 0; i < std::min(5, ChemistryODE::neqs); ++i) {
                std::cerr << s.y[static_cast<size_t>(i)] << (i < 4 ? ", " : "\n");
            }
        };
        dump_state(state);
        return 2;
    }

    // Success: print integrator statistics
    std::cout << "\nIntegrator stats:\n";
    std::cout << "  Steps taken: " << state.n_step << "\n";

    return 0;
}
