// ABOUTME: Main executable for solving chemistry ODE using header-only integrators (VODE)
// ABOUTME: Auto-generated by JAFF for chemical reaction network integration

#include "chemistry_ode.hpp"
#include <iostream>
#include <fstream>
#include <vector>
#include <string>
#include <iomanip>

using namespace integrators;

int main(int argc, char* argv[]) {
    ChemistryODE mySys{};

    // Time integration parameters
    const Real t_start = 0.0;
    Real t_end = 3.15576e9; // 100 years in seconds default

    // Parse command line arguments
    if (argc > 1) {
        t_end = std::stod(argv[1]);
    }

    std::cout << "Solving Chemistry ODE System (header-only integrators)\n";
    std::cout << "Number of species: " << mySys.neqs << "\n";
    std::cout << "Number of reactions: " << 
// PREPROCESS_NUM_REACTIONS
0
// PREPROCESS_END
     << "\n";
    std::cout << "Time interval: [" << t_start << ", " << t_end << "] seconds\n";

    // Initial conditions
    ChemistryODE::state_type y0{};
    ChemistryODE::state_type y{};

    // Default: all species start at 1e-10 except first species
    for (int i = 0; i < mySys.neqs; ++i) {
        y0[static_cast<size_t>(i)] = 1.0e-10;
    }
    if (mySys.neqs > 0) {
        y0[0] = 1.0e-6;
    }

    // Read initial conditions from file if provided
    if (argc > 2) {
        std::ifstream ic_file(argv[2]);
        if (ic_file.is_open()) {
            for (int i = 0; i < mySys.neqs && (ic_file >> y0[static_cast<size_t>(i)]); ++i) {}
            ic_file.close();
            std::cout << "Initial conditions loaded from " << argv[2] << "\n";
        }
    }

    // Print initial conditions
    std::cout << "Initial conditions:\n";
    for (int i = 0; i < mySys.neqs && i < 10; ++i) {
        std::cout << "  y[" << i << "] = " << std::setprecision(10) << y0[static_cast<size_t>(i)] << "\n";
    }
    if (mySys.neqs > 10) {
        std::cout << "  ... (showing first 10 species)\n";
    }

    // Set up integrator (VODE BDF)
    auto integrator = VODE<ChemistryODE>{};
    auto state = VODEState<static_cast<size_type>(ChemistryODE::neqs)>{};

    // Configure state
    state.t = t_start;
    state.tout = t_end;
    for (size_t i = 0; i < static_cast<size_t>(ChemistryODE::neqs); ++i) state.y[i] = y0[i];
    state.rtol = 1.e-8;
    state.atol = 1.e-20; // chemistry can have very small values
    state.max_steps = 200000;
    state.jacobian_analytic = true; // we generate an analytic Jacobian

    // Problem state (reserved for problem parameters; unused here)
    ChemistryODE::state_type problem_state{};

    auto result = integrator.integrate(problem_state, state);

    // Print final solution
    std::cout << "\nFinal solution at t = " << t_end << " seconds:\n";
    for (int i = 0; i < mySys.neqs && i < 10; ++i) {
        std::cout << "  y[" << i << "] = " << std::setprecision(10) << state.y[static_cast<size_t>(i)] << "\n";
    }
    if (mySys.neqs > 10) {
        std::cout << "  ... (showing first 10 species)\n";
    }

    // Write solution to file if output path provided
    if (argc > 3) {
        std::ofstream out_file(argv[3]);
        if (out_file.is_open()) {
            for (int i = 0; i < mySys.neqs; ++i) {
                out_file << std::setprecision(17) << state.y[static_cast<size_t>(i)] << "\n";
            }
            out_file.close();
            std::cout << "\nSolution written to " << argv[3] << "\n";
        }
    }

    // Simple conservation check
    double sum_initial = 0.0, sum_final = 0.0;
    for (int i = 0; i < mySys.neqs; ++i) {
        sum_initial += y0[static_cast<size_t>(i)];
        sum_final += state.y[static_cast<size_t>(i)];
    }
    std::cout << "\nConservation check:\n";
    std::cout << "  Initial sum: " << sum_initial << "\n";
    std::cout << "  Final sum:   " << sum_final << "\n";
    if (sum_initial != 0.0) {
        std::cout << "  Relative change: " << (sum_final - sum_initial) / sum_initial << "\n";
    }

    if (result != IntegratorResult::SUCCESS) {
        std::cerr << "\nIntegration did not succeed. Error code = " << static_cast<int>(result) << "\n";
        return 2;
    }

    return 0;
}
